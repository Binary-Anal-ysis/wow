1. Convert **Infix → Postfix** using a stack.  
2. Convert **Infix → Prefix** using a stack.  
3. Write a program to maintain **multiple stacks in a single array**.  
4. Implement **k Queues in one array** with:  
   - enqueue(x, qn)  
   - dequeue(qn)  
   - displayq(q)  
   - displayAll()  
5. Evaluate **Postfix expression** using a stack.  
6. Evaluate **Prefix expression** using a stack.  
7. Implement **Queue using circular array** with: enqueue, dequeue, isEmpty, isFull, front, rear.  
8. Check if a **singly linked list is a palindrome**.  
9. Implement **univariate polynomial addition** using linked lists.  
10. Implement **univariate polynomial multiplication** using linked lists.  
11. Implement operations on a **doubly linked list**: insert(after position), sort, display.  
12. Implement operations on a **doubly linked list**: insert(end), concatenate two lists, display.  
13. Delete all **duplicates in a sorted linked list**.  
14. **Partition a linked list** around value `x` while maintaining order.  
15. Construct a **Binary Search Tree** and perform all **recursive traversals**.  
16. Represent graph using **adjacency matrix** and perform **BFS**.  
17. Represent graph using **adjacency list** and perform **BFS**.  
18. Represent graph using **adjacency matrix** and perform **DFS**.  
19. Represent graph using **adjacency list** and perform **DFS**.  
20. Implement **Hash Table** using **linear probing** (Insert, Search).  
21. Implement **Hash Table** using **quadratic probing** (Insert, Search).  
22. Implement **Min Heap** and support: heapify, extractMin, heapsort.  
23. Add **two numbers represented by linked lists** (MSD first).  
24. Implement **Max Heap** and support: heapify, extractMax, heapsort.  
25. Rotate a **linked list** by `k` positions.  
26. Swap **nodes of a linked list in pairs**.  
27. Implement recursive operations on **singly linked list**: create, display, length, reverse.  
28. Create two sorted **singly linked lists** and perform: merge, check equality, copy list.  
29. Perform the following on a **doubly linked list**: create, display, insert, delete.  
30. Implement **stack using singly linked list** (push, pop, top, display).  
31. Implement **queue using singly linked list** (enqueue, dequeue, display, front, rear).  
32. Create a **binary tree (recursive)** and perform: inorder traversal, height.  
33. Traverse a **binary tree level-by-level** (level order).  
34. Create a **BST** and print output in **descending order**.  
35. Create two hardcoded trees and:  
    - check if they are equal,  
    - create mirror image.  
36. Create binary tree and count: terminal nodes, non-terminal nodes, total nodes.  
37. Perform **non-recursive inorder traversal** of a binary tree.  
38. Construct tree from **inorder + preorder**, then perform **recursive postorder**.  
39. Perform **non-recursive preorder traversal** of a binary tree.  
40. Perform **non-recursive postorder traversal** of a binary tree.  
